---
// Background.astro - No props needed for this component
---

<canvas id="bgCanvas" class="fixed top-0 left-0 w-full h-full -z-10"></canvas>

<script>
  import * as THREE from 'three'
  import { animateBackgroundOnScroll } from '../gsapAnimations'

  let scene: THREE.Scene,
    camera: THREE.PerspectiveCamera,
    renderer: THREE.WebGLRenderer,
    torus: THREE.Mesh,
    drawProgress: number = 0,
    isDrawing: boolean = true
  
  // Store initial viewport size
  let initialViewportHeight = window.innerHeight
  let initialViewportWidth = window.innerWidth

  // Custom shader for the drawing effect
  const wireframeVertexShader = `
  varying vec2 vUv;
  varying vec3 vNormal;

  void main() {
    vUv = uv;
    vNormal = normalMatrix * normal;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

  const wireframeFragmentShader = `
  uniform float progress;
  uniform float metalness;
  uniform float roughness;
  uniform vec3 lightDirection;
  varying vec2 vUv;
  varying vec3 vNormal;

  void main() {
    float linePosition = vUv.x + vUv.y;
    if (linePosition > progress * 2.0) discard;

    // Simple lambert diffuse
    float diffuse = max(dot(normalize(vNormal), normalize(lightDirection)), 0.0);

    // Base color (blue)
    vec3 baseColor = vec3(0.0, 247.0 / 255.0, 255.0 / 255.0);

    // Fake metalness/roughness effect
    vec3 color = mix(baseColor * diffuse, baseColor, roughness);
    color = mix(color, vec3(0.3), metalness * 0.2);

    gl_FragColor = vec4(color, 0.25);
  }
`;

  function initThree() {
    // Save initial viewport dimensions when first initializing
    initialViewportHeight = window.innerHeight
    initialViewportWidth = window.innerWidth
    
    scene = new THREE.Scene()
    camera = new THREE.PerspectiveCamera(
      75,
      initialViewportWidth / initialViewportHeight,
      0.1,
      1000,
    )

    const canvas = document.querySelector('#bgCanvas') as HTMLCanvasElement
    renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: true,
    })

    renderer.setSize(initialViewportWidth, initialViewportHeight)
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))

    // Adjust geometry complexity based on screen size
    let tubularSegments = 100
    let radialSegments = 16

    if (initialViewportWidth < 768) {
      // Reduce complexity on mobile
      tubularSegments = 64
      radialSegments = 18
    }

    // Modified geometry parameters for more angular look
    const geometry = new THREE.TorusKnotGeometry(8, 3.5, tubularSegments, radialSegments, 2, 3)

    // Create the custom shader material for the drawing effect
    const material = new THREE.ShaderMaterial({
      uniforms: {
        progress: { value: 0.0 },
        metalness: { value: 0.3 },
        roughness: { value: 0.2 },
        lightDirection: { value: new THREE.Vector3(0.5, 1.0, 0.75).normalize() }
      },
      vertexShader: wireframeVertexShader,
      fragmentShader: wireframeFragmentShader,
      wireframe: true,
      transparent: true,
    });

    torus = new THREE.Mesh(geometry, material)
    
    // Reset drawing progress
    drawProgress = 0
    isDrawing = true
    
    // Set initial torus scale
    updateTorusScale()
    
    scene.add(torus)
    animateBackgroundOnScroll('pitch', camera)
    
    const centerPointLight = new THREE.PointLight(0x9273ff, 20, 20) // Additional colored light
    centerPointLight.position.set(0, 0, 5)
    scene.add(centerPointLight)

    const ambientLight = new THREE.AmbientLight(0x9273ff, 3) // Increased ambient light
    scene.add(ambientLight)

    // Add subtle hemisphere light for better overall illumination
    const hemisphereLight = new THREE.HemisphereLight(0x9273ff, 0x9d8cff, 0.9)
    scene.add(hemisphereLight)

    camera.position.z = 30

    // Add slight rotation to initial position
    torus.rotation.x = 0.5
    torus.rotation.y = 0.5
  }

  // Function to handle responsive scaling
  function updateTorusScale() {
    if (!torus) return
    
    // Option 1: Breakpoint-based scaling
    let scale = 1.0
    
    if (initialViewportWidth < 768) {
      // For mobile devices (smaller than 768px)
      scale = 0.67
    } else if (initialViewportWidth < 1024) {
      // For tablets
      scale = 0.8
    }
    
    /* 
    // Option 2: Proportional scaling
    // Uncomment this and comment out the breakpoint code above if you prefer this approach
    const referenceWidth = 1920
    let scale = Math.max(0.5, Math.min(1.0, initialViewportWidth / referenceWidth))
    */
    
    // Apply the scale to the torus
    torus.scale.set(scale, scale, scale)
  }

  let mouseX = 0
  let mouseY = 0
  let targetRotationX = 0
  let targetRotationY = 0
  let initialTorusPosition = new THREE.Vector3()

  let animationId: number
  let lastTime = performance.now();
  
  // Flag to ignore resize events caused by browser UI changes
  let ignoreSmallResizes = true
  const resizeThreshold = 150 // Threshold in pixels to detect actual orientation changes vs UI changes

  function animate(currentTime = performance.now()) {
    animationId = requestAnimationFrame(animate);

    const deltaTime = (currentTime - lastTime) / 1000; // In seconds
    lastTime = currentTime;

    // Drawing animation using time-based progress
    if (isDrawing && torus.material instanceof THREE.ShaderMaterial) {
      drawProgress += deltaTime * 0.25; // Adjust 0.25 to control speed in sec

      torus.material.uniforms.progress.value = drawProgress;

      if (drawProgress >= 1.0) {
        isDrawing = false;
        drawProgress = 1.0;
      }
    }

    // Rotation logic (kept frame-based is usually OK for visuals)
    torus.rotation.x += 0.002;
    torus.rotation.y += 0.003;
    torus.rotation.z += 0.001;

    targetRotationX += (mouseX * 0.001 - targetRotationX) * 0.1;
    targetRotationY += (mouseY * 0.001 - targetRotationY) * 0.1;

    torus.rotation.x = targetRotationY;
    torus.rotation.y = targetRotationX;

    renderer.render(scene, camera);
  }

  function onWindowResize() {
    // Only handle significant size changes (orientation change, not browser UI)
    const heightDiff = Math.abs(window.innerHeight - initialViewportHeight)
    
    if (ignoreSmallResizes && heightDiff < resizeThreshold) {
      // This is likely a browser UI change (like search bar appearing)
      // Just resize the renderer to fit the new viewport size, but keep the camera/scene as is
      renderer.setSize(window.innerWidth, window.innerHeight)
      return
    }
    
    // For actual orientation changes/significant resizes, update everything
    initialViewportHeight = window.innerHeight
    initialViewportWidth = window.innerWidth
    
    if (camera && renderer) {
      camera.aspect = initialViewportWidth / initialViewportHeight
      camera.updateProjectionMatrix()
      renderer.setSize(initialViewportWidth, initialViewportHeight)
      
      // Update the scale whenever the window is significantly resized
      updateTorusScale()
    }
  }

  function onMouseMove(event: MouseEvent) {
    // Calculate mouse position relative to the initial viewport center
    mouseX = event.clientX - initialViewportWidth / 2
    mouseY = event.clientY - initialViewportHeight / 2
  }

  // Initialize
  document.addEventListener('DOMContentLoaded', () => {
    initThree()
    animate()

    window.addEventListener('resize', onWindowResize)
    window.addEventListener('mousemove', onMouseMove)

    // Store initial torus position after initialization
    if (torus) {
      initialTorusPosition.copy(torus.position)
    }

    // Cleanup
    return () => {
      window.removeEventListener('resize', onWindowResize)
      window.removeEventListener('mousemove', onMouseMove)
    }
  })

  document.addEventListener('astro:after-swap', () => {
    // Reset drawing animation state
    drawProgress = 0
    isDrawing = true
    
    initThree()
    cancelAnimationFrame(animationId)
    animate()

    window.addEventListener('resize', onWindowResize)
    window.addEventListener('mousemove', onMouseMove)

    // Store initial torus position after initialization
    if (torus) {
      initialTorusPosition.copy(torus.position)
    }

    // Cleanup
    return () => {
      window.removeEventListener('resize', onWindowResize)
      window.removeEventListener('mousemove', onMouseMove)
    }
  })
</script>
